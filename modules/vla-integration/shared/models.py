"""
Data models for the Vision-Language-Action (VLA) integration system.

This module defines the core data structures used across the VLA system:
- VoiceCommand: A spoken instruction that contains intent and parameters for robot action
- ActionPlan: A sequence of discrete actions generated by the cognitive planning system to fulfill a command
- RobotState: The current status of the robot including position, orientation, and available capabilities
- EnvironmentalContext: Information about the robot's surroundings including object locations and navigable paths
- UserIntent: The understood purpose behind a voice command as interpreted by the LLM
- ExecutionResult: Result of executing an action or action plan
"""

from dataclasses import dataclass
from datetime import datetime
from typing import List, Dict, Optional, Any
from enum import Enum


class CommandStatus(Enum):
    """Status of a voice command processing"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


class SafetyStatus(Enum):
    """Safety status of the robot"""
    SAFE = "safe"
    WARNING = "warning"
    UNSAFE = "unsafe"


class ActionType(Enum):
    """Type of action that can be performed"""
    NAVIGATION = "navigation"
    MANIPULATION = "manipulation"
    DETECTION = "detection"


@dataclass
class Position3D:
    """3D position coordinates"""
    x: float
    y: float
    z: float


@dataclass
class Orientation:
    """Orientation as quaternion"""
    x: float
    y: float
    z: float
    w: float


@dataclass
class VoiceCommand:
    """
    A spoken instruction that contains intent and parameters for robot action

    Fields:
    - id: Unique identifier for the command
    - text: The transcribed speech text
    - timestamp: When the command was received
    - confidence: Confidence score from speech-to-text processing (0.0-1.0)
    - intent: The interpreted intent from LLM processing
    - parameters: Extracted parameters for the action
    - status: Current status (pending, processing, completed, failed)
    """

    id: str
    text: str
    timestamp: datetime
    confidence: float
    intent: str
    parameters: Dict[str, Any]
    status: CommandStatus

    def __post_init__(self):
        """Validate the VoiceCommand after initialization"""
        if not self.text.strip():
            raise ValueError("Text must not be empty")

        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")


@dataclass
class Action:
    """
    An individual action within an action plan

    Fields:
    - type: Type of action (navigation, manipulation, detection)
    - parameters: Specific parameters for the action
    - priority: Priority level for execution
    - dependencies: IDs of actions that must complete first
    """

    type: ActionType
    parameters: Dict[str, Any]
    priority: int
    dependencies: List[str]


@dataclass
class ActionPlan:
    """
    A sequence of discrete actions generated by the cognitive planning system to fulfill a command

    Fields:
    - id: Unique identifier for the action plan
    - voice_command_id: Reference to the original voice command
    - actions: Ordered list of action objects
    - status: Current status (pending, executing, completed, failed)
    - created_at: When the plan was created
    - estimated_duration: Estimated time to complete in seconds
    """

    id: str
    voice_command_id: str
    actions: List[Action]
    status: CommandStatus
    created_at: datetime
    estimated_duration: float

    def __post_init__(self):
        """Validate the ActionPlan after initialization"""
        if not self.actions:
            raise ValueError("ActionPlan must contain at least one action")

        valid_action_types = [action_type.value for action_type in ActionType]
        for action in self.actions:
            if action.type.value not in valid_action_types:
                raise ValueError(f"Action type must be one of {valid_action_types}")

        # Check that dependencies reference existing actions in this plan
        action_ids = [f"action_{i}" for i in range(len(self.actions))]
        for action in self.actions:
            for dep_id in action.dependencies:
                if dep_id not in action_ids:
                    raise ValueError(f"Dependency {dep_id} does not exist in this plan")


@dataclass
class RobotState:
    """
    The current status of the robot including position, orientation, and available capabilities

    Fields:
    - id: Unique identifier for the robot state
    - position: 3D position coordinates (x, y, z)
    - orientation: Orientation as quaternion (x, y, z, w)
    - battery_level: Current battery level (0.0-1.0)
    - available_capabilities: List of available robot capabilities
    - safety_status: Current safety status (safe, warning, unsafe)
    - timestamp: When the state was recorded
    """

    id: str
    position: Position3D
    orientation: Orientation
    battery_level: float
    available_capabilities: List[str]
    safety_status: SafetyStatus
    timestamp: datetime

    def __post_init__(self):
        """Validate the RobotState after initialization"""
        if not 0.0 <= self.battery_level <= 1.0:
            raise ValueError("Battery level must be between 0.0 and 1.0")


@dataclass
class ObjectInfo:
    """
    Information about a detected object

    Fields:
    - id: Unique identifier for the object
    - type: Type/class of the object (cube, cup, etc.)
    - position: 3D position coordinates
    - confidence: Confidence in object detection (0.0-1.0)
    """

    id: str
    type: str
    position: Position3D
    confidence: float

    def __post_init__(self):
        """Validate the ObjectInfo after initialization"""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")


@dataclass
class EnvironmentalContext:
    """
    Information about the robot's surroundings including object locations and navigable paths

    Fields:
    - id: Unique identifier for the environmental context
    - timestamp: When the context was captured
    - objects: List of detected objects with properties
    - navigable_areas: List of navigable regions
    - obstacles: List of detected obstacles
    - robot_position: Current robot position in the environment
    """

    id: str
    timestamp: datetime
    objects: List[ObjectInfo]
    navigable_areas: List[Dict[str, Any]]
    obstacles: List[Dict[str, Any]]
    robot_position: Position3D


@dataclass
class UserIntent:
    """
    The understood purpose behind a voice command as interpreted by the LLM

    Fields:
    - id: Unique identifier for the user intent
    - voice_command_id: Reference to the original voice command
    - primary_intent: Primary action the user wants performed
    - parameters: Extracted parameters from the command
    - confidence: Confidence in intent interpretation (0.0-1.0)
    - created_at: When the intent was processed
    """

    id: str
    voice_command_id: str
    primary_intent: str
    parameters: Dict[str, Any]
    confidence: float
    created_at: datetime

    def __post_init__(self):
        """Validate the UserIntent after initialization"""
        if not self.primary_intent.strip():
            raise ValueError("Primary intent must not be empty")

        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")


@dataclass
class ActionResult:
    """
    Result of executing a single action

    Fields:
    - action_id: ID of the executed action
    - status: Status of the action (success, failed, skipped)
    - details: Additional details about the execution
    - duration: Time taken for this action in seconds
    """

    action_id: str
    status: str  # Using string instead of enum to allow more flexibility
    details: str
    duration: float


@dataclass
class ExecutionResult:
    """
    Result of executing an action or action plan

    Fields:
    - id: Unique identifier for the execution result
    - action_plan_id: Reference to the action plan executed
    - results: Individual results for each action
    - overall_status: Overall execution status (success, partial, failure)
    - execution_time: Time taken for execution in seconds
    - timestamp: When the execution completed
    """

    id: str
    action_plan_id: str
    results: List[ActionResult]
    overall_status: str  # Using string instead of enum to allow more flexibility
    execution_time: float
    timestamp: datetime